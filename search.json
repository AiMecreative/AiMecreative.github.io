[{"title":"HPC | Introduction to Parallel Computation","url":"/2024/04/09/HPC/intro/","content":"Parallel Programming: Concepts and Pracitce - Chapter 1\r\n\r\n概念\r\n加速比\r\nSpeedup：衡量一个并行算法比串行算法快多少的指标。即使用单个处理器运行程序所花费的时间\r\n 与使用  个处理器运行程序所花费的时间  之比\r\n\r\n通常我们希望得到的加速比为线性加速比，即用  个处理器去运行程序，最大的加速比为\r\n\r\n效率\r\nEfficiency：定义为加速比和处理器数目之比，衡量了平均一个处理器带来的加速比。当效率为\r\n 时，此时为线性加速比\r\n\r\n可扩展性\r\nScalability：分为强可扩展性和弱可扩展性。\r\n\r\n强可扩展性 Strong\r\nScalability：测量效率时仅改变处理器的数目，输入数据的规模保持不变\r\n弱可扩展性 Weak\r\nScalability：处理器的数目随着输入数据规模共同变化（处理器数目翻倍时，测量效率时把数据规模也翻倍）\r\n\r\n计算通信比 Computation-to-communication\r\nRatio：定义为计算花费的时间和处理器间处理消息通信花费的时间之比。\r\n分布式内存系统：每个计算单元只能访问自己的本地内存，如果需要访问其它单元，需要通过一个显式的通信步骤（例如通信网络）实现。\r\n共享式内存系统：所有计算单元共享内存，除此之外，自己本身也有更小的内存（分级缓存）。\r\n并行程序设计时需要考虑划分（数据并行、任务并行、模型并行）、通信、同步和负载平衡等。\r\n求和的例子\r\n现在我们进行一组数据的加法求和操作，其中数据量为  ，处理器数量为  。设 \r\n为一次加法操作所需要的时长，  为一批数据的通信时长。则\r\n\r\n数据分发次数：\r\n每个处理器本地求和：\r\n每个处理器将结果传递给一个处理器（数据收集）：\r\n中间结果求和：\r\n\r\n总的求和运行时长为\r\n\r\n其加速比为\r\n\r\n对于固定的 ，加速比只与计算通信比 \r\n有关，并且有\r\n\r\n因此在固定数据规模和处理器数量时，要提高加速比，需要降低计算通信比。同时，加速比也可以是处理器数量的函数：\r\n\r\n令偏导为 ，解出最值条件 \r\n综上所述，有如下规律：\r\n\r\n当数据规模固定时，加速比依赖于采用的计算单元的数目和计算通信比\r\n\r\n通常情况下，加速比随着计算单元的增加达到局部最大，但使用更多计算单元时，加速比会降低\r\n最优的加速比依赖于计算通信比，通信时长占比越大，使用的计算单元数目应该越少\r\n\r\n\r\n前缀和的例子\r\n前缀和问题：现有  个数据和\r\n 个计算结点\r\n\r\n输入：一个二元可结合运算符 ； 个待运算的数据 \r\n输出： 个数据 ，其中对于 \r\n\r\n由于计算  需要依赖 ，在循环分析时带来了一定的困难，但该问题依然有并行的方式。\r\n\r\n数据划分：使用 分治 策略，将  个数据按顺序均分为  份，分别分给 \r\n个计算结点，每个结点计算本地内存的前缀和，花费的时间为 \r\n数据归并：递归\r\n合并相邻的结点数据，即左边结点将前缀和的 最后一个结果\r\n返回，传递给右边结点，右边结点接收左边的前缀和，并将其与自己结点结果求和\r\n所有线程将结果返回，计算完成\r\n\r\n\r\n\r\nperfix sum\r\n\r\n前缀和问题将在后续进行更加详细的讨论。\r\n","categories":["HPC"],"tags":["HPC"]},{"title":"AICompiler | Auto Differentiation","url":"/2024/09/01/Compiler/auto_grad/","content":"微分\r\n\r\n综述：机器学习中的自动微分\r\n张量自动微分 关于自动微分的编程系统\r\n\r\n符号微分：直接使用链式法则对表达式求导。优点是数值精确，缺点为表达式膨胀\r\n数值微分：使用有限差分求解：\r\n\r\n数值微分会由于计算机中不同浮点数精度（FP16, FP32,\r\nFP64）而造成截断误差（truncation error）和舍入误差（round-off\r\nerror）\r\n自动微分：\r\n\r\n所有数值运算都由有限的基本运算构成\r\n基本运算的导数表达式已知\r\n通过链式法则链接将数值计算各部分组合为整体\r\n\r\n自动微分中的 表达式追踪（Evaluation trace）\r\n能追踪数值计算过程中的中间变量。以下述函数为例\r\n\r\n表示为计算图为\r\n\r\n\r\ncomputation_graph\r\n\r\n前向微分 (forward mode)\r\n从输入出发，逐步使用链式法则进行求导。\r\n\r\n\r\nforward\r\n\r\n\r\n通过一个输入可以求解所有的输出微分，不适用与深度学习多输入少输出的情况\r\n\r\n后向微分 (backward mode)\r\n对于每一个结点，求解最终输出对该结点的导数。注意每一次求导需要用到后继相邻结点的导数。\r\n\r\n\r\nreverse\r\n\r\n\r\n可以一次性求解所有输入的微分，但需要大量存储空间存储中间结果的微分\r\n\r\nJacobian 矩阵\r\n前向和后向微分都可以使用 Jacobian 矩阵来表示：对于函数 \r\n\r\n称为原函数的 Jacobian 矩阵。其中每行为后向微分 (Adjoint)\r\n的求解结果，每列为前向微分 (Tangent) 的求解结果。\r\n\r\n输出数量小于输入时，常用后向微分方法；反之前向。\r\n\r\n自动求导实现方法\r\n\r\nLIB：基本表达式，封装基本的表达式及其微分表达式作为库函数，运行时记录基本表达式和相应的组合方式，使用链式法则对基本表达式的微分结果进行组合\r\nOO：操作符重载，利用语言多态，使用操作符重载基本表达式运算符，其余类似LIB，代表库为PyTorch\r\nAST：源码转换，语言预处理、编译器或解释器的扩展，对程序表达进行分析得到基本表达式的组合方式，代表库为MindSpore\r\n\r\n","categories":["Compiler"],"tags":["Compiler"]},{"title":"AICompiler | AI Framework","url":"/2024/09/02/Compiler/ai_frame/","content":"AI 框架\r\n\r\n前端：面向用户的编程语言和接口。C++，Python，Lua等\r\n统一表示：神经网络的中间表示、计算图\r\n优化层：\r\n\r\n自动微分\r\n计算图优化\r\n\r\n运行时：内存管理、计算图调度和执行\r\n底层库：\r\n\r\n内核代码的优化和编译\r\n多硬件支持\r\n\r\n\r\n","categories":["Compiler"],"tags":["Compiler"]},{"title":"HPC | Theory Backgroud","url":"/2024/04/11/HPC/theory/","content":"Parallel Programming: Concepts and Pracitce - Chapter 2\r\n\r\n首先介绍并行随机访问机器（PRAM）模型是抽象的共享内存模型，其忽略了现实计算机中的开销，但可以帮助设计一些并行算法。其次是对于分布式内存模型，会介绍一些基础图论知识。接着介绍并行程序中的两大定律：Amdahl定律和Gustafson定律，用于推断并行程序加速比能达到的上限。最后以并行算法设计的Foster方法论结束。\r\n并行随机访问机器模型\r\n事实上，PRAM (Parallel Random Access Machine)\r\n模型架构十分简单，相比于操作系统课上的一个处理器而言，PRAM拥有多个独立的处理器，每个处理器分3个阶段执行一个指令周期：\r\n\r\n读阶段：每个处理器并发地从各自的共享内存中读取单条数据并保存到本地的寄存器中。\r\n计算阶段：每个处理器对本地数据执行一个基本操作，并将结果存储在寄存器中。\r\n写阶段：每个处理器并发写一条数据到共享内存中。\r\n\r\nPRAM中的通信通过处理器在共享内存中的读写实现，该类型的内存能够以统一的方式访问，即每个处理器对内存中任意位置的访问都使用统一的常数时间实现，这和现实计算机很不一样（访问大规模共享内存时耗费的时间不一致）。\r\nPRAM的变体\r\n在相同的指令中期中，多个处理器读写多个共享内存单元会发生冲突，为解决冲突，出现了如下的几种PRAM变体：ER\r\n(exclusive read)，EW (exclusive write)，CR (concurrent read)，CW\r\n(concurrent write)。常见的组合有三种：\r\n\r\nEREW：独占读、独占写。任意周期内，不允许多个处理器在相同的共享内存单元中进行读写。\r\nCREW：并发读、独占写。\r\nCRCW：并发读、并发写。对于并发写入，有常见的数据保留形式：\r\n\r\nPriority: 处理器本身的优先级决定\r\nArbitrary: 随机选取一个处理器的值写入\r\nCommon: 若所有的值都相等则写入，否则内存位置的值不变\r\nCombining: 通过某种运算组合所有的冲突值再写入\r\n\r\n\r\nPRAM上的前缀和算法\r\n问题描述：给定 \r\n个数据，和一个该数据的二元运算符，假设为加法运算。在一台拥有  个计算结点的PRAM上，并行计算前缀和。\r\n其中数据已经存储在了共享内存 A 中，每个计算结点的寄存器用\r\nreg 表示，目标是设计一个开销最优化的PRAM算法。\r\n串行分析：使用一个计算结点求解前缀和问题\r\nfor (int i = 1; i &lt; n; i += 1) A[i] += A[i-1];\r\n计算复杂度为 \r\n。\r\n并行分析：使用  个计算结点并行求解前缀和问题\r\n当 \r\n时，计算结点的数量和数据量相等，每个计算结点上处理一个数据。\r\n可以使用分治递归的方式，将计算结点逐一合并。\r\n//-- 算法 1 --//// load data for every node@parallelfor (int i = 0; i &lt; p; i += 1) {    reg[i] = A[i];}// total iteration num, merge by 2for (int i = 0; i &lt; ceil(log(p)); i += 1) {    // the left nodes have been calculated    int node_start_idx = pow(2, i);    @parallel    for (int j = node_start_idx; j &lt; p; j += 1) {        reg[j] += A[j - node_start_idx];        A[j] = reg[j];    }}\r\n总体的计算结构类似于二叉树：每一个结点都与左边相邻结点进行计算前缀和，第\r\n 次迭代中，每  个结点视为一个 merge 的结点，\r\n因此一共需要  次递归，即花费的时间为 ， 开销为\r\n，是对数线性的。\r\n如果需要继续减小开销 ，则要么减小 ，要么减小 ，降低运行时间比较困难，因此选择减少计算结点的数量\r\n，即  方法如下\r\n\r\n我们有  个计算结点，先将\r\n\r\n个数据均分到每个计算结点上，每个结点有  个数据\r\n每个计算结点对本地内存的数据求解前缀和，花费的时间为 \r\n每个结点返回本地前缀和的最后一位结果，得到一共  个数据\r\n对上述 \r\n个数据执行算法1，花费的时间为 ，计算完成后依然得到长度为  的前缀和 A_p\r\n将第4步得到的前缀和 A_p[j]，依次加到\r\nreg[j+1] 上，A_p\r\n的最后一位不用加，由于每个结点有  个数据，因此花费的时间为 \r\n\r\n综上所述，整个算法的时间为 ，开销为 ，\r\n当 \r\n时，计算时间为对数，且开销为线性的。\r\n//-- 算法 2 --//// stage 1-3// calculate prefix sum for every node// each node contains k = n/p = log(n) datak = n/p = log(n)@parallelfor (int i = 0; i &lt; p; i += 1) {    for (int j = 1; j &lt; k; j += 1) {        // data index: i * num + offsets        A[i*k+j] += A[i*k+j-1]    }}// stage 4// calculate prefix sum for rightmost values of every nodefor (int i = 0; i &lt; log(p); i += 1) {    int node_start_idx = pow(2, i);    @parallel    for (int j = node_start_idx + 1; j &lt; p; j += 1) {        A[j*k-1] += A[(j - node_start_idx)*k-1]    }}// stage 5// add results@parallelfor (int i = 1; i &lt; p; i += 1) {    // ignore the last value    for (int j = 0; j &lt; k-1; j += 1) {        A[i*k+j] += A[i*k-1]    }}\r\nPRAM上的稀疏矩阵压缩算法\r\n稀疏矩阵压缩算法可以利用前缀和算法。\r\n问题描述：稀疏数组 A 中多个元素为 ，希望能通过并行算法压缩为非零数组\r\nV 和对应的位置数组 C。\r\n\r\n构造和 A 等长的临时数组 temp，其中若\r\ntemp[i] = 1 if A[i]!=0 else temp[i]=0， 将数组\r\nA 和临时数组 temp 均分到 \r\n个计算结点上，并行生成临时数组和计算临时数组的前缀和\r\n求完前缀和的临时数组目前可以作为稀疏数组的\r\n地址列表，接下来根据临时数组，并行索引 A\r\n中对应地址，得到非零值和位置，写入 V,C 即可\r\n\r\n分析：\r\n网络拓扑\r\n互联网络的结点可能是交换机或处理器。几个概念：\r\n\r\n度(degree)：网络的度表示所有结点中邻居数目的最大值\r\n对分宽度(bw)：将网络分为二分图，两个分图间边的最小值\r\n直径(diam)：任意两个结点之间全部最短路径的最大值\r\n\r\n在设计互联网络时，经常关注以下 理想属性：\r\n\r\n常数度：网络的度是常数，即与网络的规模无关。这个属性允许网络扩大到更大的规模而无需增加过多的连接数\r\n小直径：可以支持任意进程之间的高效通信\r\n高对分宽度：对分宽度越低，大量聚合的通信操作会变得更慢，它隐含的是网络的内部带宽\r\n\r\n经典网络拓扑结构各属性的阶：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ntopology\r\ndegree\r\ndiam\r\nbw\r\n\r\n\r\n\r\n\r\n线性排列\r\n\r\n\r\n\r\n\r\n\r\n2D网面/环面\r\n\r\n\r\n\r\n\r\n\r\n3D网面/环面\r\n\r\n\r\n\r\n\r\n\r\n二叉树\r\n\r\n\r\n\r\n\r\n\r\n超立方体\r\n\r\n\r\n\r\n\r\n\r\n\r\nAmdahl's Law and Gustafson's\r\nLaw\r\n如果能在设计并行算法前，能对一个问题提前分析其并行效果，将会减少不必要的工作量，也能了解到并行算法是否值得，\r\n而 Amdahl 定律和 Gustafson 定律能帮助我们进行加速比的估计。\r\n一段程序的总执行时间可以分为未被并行化部分所花费的时间（即不能被并行化或没有被并行化的部分所花的时间）\r\n和并行运行的时间，分别用符号  表示。 单个处理器运行一段程序的时间  即上述两部分的简单相加：\r\n\r\nAmdahl's Law\r\n在不考虑缓存效应的前提下，我们希望最佳加速比是线性的： 也就是说如果有\r\n\r\n个处理器并行一段程序，其并行部分能比单个处理器运行快  倍，\r\n因而可以导出一般情况下的运行时间下限：\r\n\r\n因此可以得到其加速比的上限：\r\n\r\n一般而言，在只讨论串行时间和并行时间时，我们使用百分比来表示二者的关系：\r\n\r\n其中 \r\n是一个介于0，1之间的数，此时的加速比可以表示成  的函数：\r\n\r\n这便是 Amdahl 定律。通过知道 ，我们就能预测使用多个处理器并行化程序的加速比理论上限。\r\nAmdahl定律的限制：只适用于问题规模为\r\n常数、处理器个数变化的情况，即强可扩展性。\r\nGustafson's Law\r\n如果在增加处理器个数的情况下，同时增大问题规模，花在并行部分的时间\r\n 比串行时间  增长得更快。\r\n为了同时考虑这些情况，可以按照问题的复杂性扩展两个部分的规模：\r\n\r\n：根据问题规模的复杂度，不能从并行化中获益的程序部分的\r\n尺度函数\r\n：根据问题规模的复杂度，能从并行化中获益的程序部分的尺度函数\r\n\r\n对于单个处理器的情况，程序运行时间为：\r\n\r\n因此得到可达加速比（即并行的最高加速比按照线性加速比处理）：\r\n\r\n令 ：\r\n\r\n\r\n当 \r\n时，即问题规模增加时，串行和并行的尺度增加一致，此时为Amdahl定律；\r\n（Gustafson 定律）当 \r\n时，，即可并行部分以线性  增长，不可并行部分保持常数\r\n\r\nFoster的并行算法设计方法学\r\n","categories":["HPC"],"tags":["HPC"]},{"title":"HPC | Modern Architecture-Cache","url":"/2024/04/23/HPC/modern_arch/","content":"Parallel Programming: Concepts and Pracitce - Chapter 3\r\n\r\nvon Neumann bottleneck:\r\n现代微处理器能够以远高于从主存（DRAM）中读取数据的速率处理数据。\r\n导致的结果是，很多程序受限于访存，而非计算。当然，现在也有很多访存友好的算法，\r\n例如 BLAS 库中的 GEMM\r\n缓存算法\r\n缓存算法主要解决以下问题：\r\n\r\n我们需要从主存装载哪些数据，储存在何处\r\n缓存已满时，我们需要移出哪些数据\r\n\r\n缓存算法的目的在于优化其 命中率（cache\r\nhit）。算法遵循以下两条原则：\r\n\r\n空间局部性：许多算法会从连续的内存位置访问数据，有较高的空间局部性。例如如下程序：\r\n\r\nfor (int i = 0; i &lt; size; i += 1) {    max_value = max(a[i], max_value);}\r\n起始缓存为空，访问 a[0]\r\n时缓存未命中，需要载入数据，缓存一般一次载入一个完整的 cache\r\nline。 假设 cache line\r\n大小是64B，数组的值是双精度浮点数（float64），则连续的8个值\r\na[0:8] 会一起被载入缓存， a[1:8]\r\n的数据全部缓存命中。\r\n\r\n时间局部性：缓存被组织为一定数目的块，即 cache\r\nline。每个块有固定的大小。缓存映射策略可以决定主存的一个特定条目的备份在缓存中的存储位置。\r\n\r\n直接映射缓存 direct-mapping\r\ncache：主存每个特定条目在缓存中有唯一的存储位置。命中率较低。\r\n2路组相联缓存 two-way set associative\r\ncache：从主存载入的数据可以存储在2个可能的块中，具体存储的位置由\r\n最近最少使用（least-recently used, LRU）\r\n原则决定，往往会选择最近时间最少使用的那个块用来存储主存载入的数据。命中率高于直接映射。常用的还有4路、8路等。\r\n\r\n\r\n缓存一致性\r\n假设需要修改缓存中的值，则不仅需要修改缓存中的值，还需要修改主存中的值，不然会产生不一致（inconsistency），\r\n有两种策略去保证缓存和主存中的一致性（coherence）：\r\n\r\n直写式：如果主存中的数据已经缓存，则主存数据发生变动的同时也要修改缓存的值。缺点每次写主存需要一次主存访问\r\n回写式：缓存的值修改时，不会立马修改主存的值，而是会被标记为\r\ndirty，待数据移出缓存时，才写入主存\r\n\r\n多级缓存和多核处理器的情况会非常复杂，例如每个处理器有自己的本地缓存L1，同时所有的处理器又共享一个公共缓存L2，每个处理器修改L1时，如果没有约束条件，可能会导致其它处理器缓存的值与修改后不一致，L1的值与L2的值也不一样。\r\n一种方式是对于缓存且被修改的值，让其它处理器标记该数据的缓存行为失效，除非重新从主存中载入数据。常用的协议有MESI协议。\r\n虚假共享：缓存一致性协议是对于 cache line\r\n而言的，每一行能存多个值，如果修改了某个值，其所在的 cache line\r\n以及其所关联的 cache line （其它核心的 cache\r\nline）将会整体失效。一个极端情况是，多个处理器同时修改一个缓存行的不同数据，任意一个写操作都会使缓存行失效，所有处理器都需要从共享主存重新载入数据，即使数据并没有改变。这种情况就是\r\n虚假共享。\r\n对于程序员的准则：\r\n\r\n避免对存储在同一个缓存行中的条目进行过度更新\r\n尽量在寄存器而不是在缓存中存储中间结果\r\n\r\n如果数据没有被缓存，则数据仍然需要从主存中缓慢地传送出来，其访问时间在CPU或者GPU上会高达几百个时钟周期，解决的方式有\r\n\r\n并发多线程技术 simultaneous multi-threading,\r\nSMT：在多个线程之间快速切换，用计算时间掩盖访问时间\r\n硬件预取技术 hardware\r\nprefetching：在能预先知道处理器需要的数据时，在使用这些数据前通过硬件（目前也可由程序员自行编程实现）提前将其装载在缓存中\r\n\r\nFlynn分类法\r\n将处理器的并行性根据体系结构的指令和数据流分为4种类型：\r\n\r\n\r\nFlynn Taxonomy\r\n\r\n\r\nSISD：即传统的 von Neumann\r\n体系结构，单个串行的处理单元操作单个数据\r\nSIMD：在多个数据上并发地执行同一个操作\r\nMIMD：多个处理单元在多个数据上进行不同的指令\r\nMISD：多个处理单元在单个数据流上执行不同的指令，并行性少见，但可用于流水线体系结构\r\n\r\n现代CPU和GPU在不同层次上的并行：\r\n\r\n多重核心：集成一定数量的核心（或者多处理器构成的流水线），能异步独立执行多个线程，现代微处理器使用MIMD并行\r\n向量单元：基于每个处理器上的SIMD向量单元实现数据并行性，例如512位的向量单元可以并行执行16对单精度浮点数的加法操作\r\n指令级并行：通过指令流水线和超标量执行实现\r\n\r\nSIMD：在每个时钟周期，通过向全体可用的处理单元（Processint\r\nElement, PE）或者计算逻辑单元（Arithetic Logical Unit,\r\nALU）分发相同的指令，SIMD体系结构实现数据并行（data\r\nparallelism）机制。因此该体系结构只需要一个单独的控制单元。例如对于简单的向量逐元素相减：\r\nfor (int i = 0; i &lt; n; i += 1) {  w[i] = u[i] - v[i];}\r\n由于循环中的每个迭代都是独立且规则的，考虑n个ALU在单独控制单元下运行，只需要将向量的每个元素u[i], v[i]放入对应的寄存器U, V，再执行简单的减法操作U-V，ALU[i]便能计算出对应的值w[i]。\r\n但并非所有算法都对SIMD友好，例如在循环中加入条件语句：\r\nfor (int i = 0; i &lt; n; i += 1) {  if (u[i] &gt; 0) {    w[i] = u[i] - v[i];  } else {    w[i] = u[i] + v[i];  }}\r\n为了将带有条件语句的for语句映射到SIMD体系结构上，需要允许ALU存在idle状态，即跳过一次计算，此时上述代码可以分为三步进行数据并行：\r\n\r\n判断向量u各个元素与0的大小并标记对应的ALU是否执行第1个条件语句块，是则非idle状态，否则为idle状态\r\n非idle状态的ALU执行语句\r\n反转各ALU的idle状态，执行语句\r\n\r\n在x86架构上已经可以使用SSE（流式SIMD扩展）进行向量计算。通过AVX（Advanced\r\nVector\r\nExtension），可以使用内联函数（intrinsic）开发向量寄存器。可以实现下面程序，测试普通矩阵乘法、转置矩阵乘法和AVX转置矩阵乘法之间的性能差距：\r\n#include &lt;chrono&gt;#include &lt;corecrt_math.h&gt;#include &lt;cstdint&gt;#include &lt;intrin.h&gt;#include &lt;iostream&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;// #include \"include/hpc_helpers.hpp\"#define TIMERSTART(label)                                                      \\  std::chrono::time_point&lt;std::chrono::system_clock&gt; a##label, b##label;       \\  a##label = std::chrono::system_clock::now();#define TIMERSTOP(label)                                                       \\  b##label = std::chrono::system_clock::now();                                 \\  std::chrono::duration&lt;double&gt; delta##label = b##label - a##label;            \\  std::cout &lt;&lt; \"# elapsed time (\" &lt;&lt; #label &lt;&lt; \"): \" &lt;&lt; delta##label.count()   \\            &lt;&lt; \"s\" &lt;&lt; std::endl;#define PRINT_MATRIX(mat, row, col)                                            \\  for (int i = 0; i &lt; row; i += 1) {                                           \\    for (int j = 0; j &lt; col; j += 1) {                                         \\      std::cout &lt;&lt; mat[i * col + j] &lt;&lt; \" \";                                    \\    }                                                                          \\    std::cout &lt;&lt; std::endl;                                                    \\  }// If the matrices are too huge, don't use this functionvoid SISDNaiveMatrixMult(std::vector&lt;float&gt; a, std::vector&lt;float&gt; b,                         std::vector&lt;float&gt; &amp;c, const uint64_t row_a,                         const uint64_t col_a, const uint64_t row_b,                         const uint64_t col_b) {  if (col_a != row_b) {    std::cout &lt;&lt; \"Shape error, two matrices can't be multiplied.\" &lt;&lt; std::endl;    return;  }  TIMERSTART(SISD_naive_mm)  for (uint64_t i = 0; i &lt; row_a; i += 1) {    for (uint64_t j = 0; j &lt; col_b; j += 1) {      float accum = 0;      for (uint64_t k = 0; k &lt; col_a; k += 1) {        accum += a[i * col_a + k] * b[k * col_b + j];      }      c[i * col_b + j] = accum;    }  }  TIMERSTOP(SISD_naive_mm)}// Transpose matrix b firstly, and then do multiplyvoid SISDTransposeMatrixMult(std::vector&lt;float&gt; a, std::vector&lt;float&gt; b,                             std::vector&lt;float&gt; &amp;c, const uint64_t row_a,                             const uint64_t col_a, const uint64_t row_b,                             const uint64_t col_b) {  if (col_a != row_b) {    std::cout &lt;&lt; \"Shape error, two matrices can't be multiplied.\" &lt;&lt; std::endl;    return;  }  std::vector&lt;float&gt; bt(b);  TIMERSTART(SISD_transpose_mm)  TIMERSTART(SISD_transpose)  for (uint64_t i = 0; i &lt; row_b; i += 1) {    for (uint64_t j = 0; j &lt; col_b; j += 1) {      bt[j * row_b + i] = b[i * col_b + j];    }  }  TIMERSTOP(SISD_transpose)  TIMERSTART(SISD_mm)  for (int i = 0; i &lt; row_a; i += 1) {    for (int j = 0; j &lt; col_b; j += 1) {      float accum = 0;      for (int k = 0; k &lt; col_a; k += 1) {        accum += a[i * col_a + k] * bt[j * row_b + k];      }      c[i * col_b + j] = accum;    }  }  TIMERSTOP(SISD_mm)  TIMERSTOP(SISD_transpose_mm)}void SIMDTransposeMatrixMult(std::vector&lt;float&gt; a, std::vector&lt;float&gt; b,                             std::vector&lt;float&gt; &amp;c, const uint64_t row_a,                             const uint64_t col_a, const uint64_t row_b,                             const uint64_t col_b) {  if (col_a != row_b) {    std::cout &lt;&lt; \"Shape error, two matrices can't be multiplied.\" &lt;&lt; std::endl;    return;  }  std::vector&lt;float&gt; bt(b);  TIMERSTART(SIMD_transpose_mm)  TIMERSTART(SIMD_transpose)  for (uint64_t i = 0; i &lt; row_b; i += 1) {    for (uint64_t j = 0; j &lt; col_b; j += 1) {      bt[j * row_b + i] = b[i * col_b + j];    }  }  TIMERSTOP(SIMD_transpose)  TIMERSTART(SIMD_mm)  for (uint64_t i = 0; i &lt; row_a; i += 1) {    for (uint64_t j = 0; j &lt; col_b; j += 1) {      auto accum = _mm_setzero_ps();      // 128 bit, 4 float32      for (uint64_t k = 0; k &lt; col_a; k += 8) {        auto ai = _mm_loadu_ps(&amp;a[i * col_a + k]);        auto bi = _mm_loadu_ps(&amp;bt[j * row_b + k]);        accum = _mm_add_ps(_mm_mul_ps(ai, bi), accum);        auto ai2 = _mm_loadu_ps(&amp;a[i * col_a + k + 4]);        auto bi2 = _mm_loadu_ps(&amp;bt[j * row_b + k + 4]);        accum = _mm_add_ps(_mm_mul_ps(ai2, bi2), accum);      }      c[i * row_a + j] = accum[0] + accum[1] + accum[2] + accum[3];    }  }  TIMERSTOP(SIMD_mm)  TIMERSTOP(SIMD_transpose_mm)}int main() {  const uint64_t row_a = 1 &lt;&lt; 11;  const uint64_t col_a = 1 &lt;&lt; 11;  const uint64_t row_b = 1 &lt;&lt; 11;  const uint64_t col_b = 1 &lt;&lt; 11;  std::vector&lt;float&gt; a(row_a * col_a, 1.);  std::vector&lt;float&gt; b(row_b * col_b, 1.);  std::vector&lt;float&gt; c(row_a * col_b, 0.);  // SISDNaiveMatrixMult(a, b, c, row_a, col_a, row_b, col_b);  // SISDTransposeMatrixMult(a, b, c, row_a, col_a, row_b, col_b);  SIMDTransposeMatrixMult(a, b, c, row_a, col_a, row_b, col_b);  return 0;}\r\n上述程序的输出为（i7-11800H）：\r\n# elapsed time (SISD_naive_mm): 174.542s# elapsed time (SISD_transpose): 0.0413579s# elapsed time (SISD_mm): 44.8414s# elapsed time (SISD_transpose_mm): 44.8848s# elapsed time (SIMD_transpose): 0.0398632s# elapsed time (SIMD_mm): 15.4761s# elapsed time (SIMD_transpose_mm): 15.5185s\r\n","categories":["HPC"],"tags":["HPC"]},{"title":"Lecture | Algorithm Review","url":"/2024/12/03/Lecture/algorithm_review/","content":"Algrithm Review Notes\r\nBasic\r\n\r\n\r\n简述快速排序中划分过程的作用。\r\n\r\n\r\n快速排序划分可以将整个数组划分为两部分，使得数组右边小于左边（升序），而用于划分数组的基准元被放到了正确的位置。从而在递归排序时每次划分都满足上述性质，合并后可以完成整个数组的排序。\r\n\r\n\r\n使用快速排序算法针对数组进行升序排序，以最右边元素作为主元，请写出针对（600,\r\n500, 400, 300, 200, 100）这个输入实例进行排序的执行过程。\r\n简述分治法与平衡的关系，并阐述你对快速排序算法中平衡的理解。\r\n\r\n\r\n分治与平衡密不可分，具有平衡结构的分治效率往往更高。\r\n\r\n\r\n\r\n\r\n\r\n× × √ √ ×\r\n\r\n\r\n\r\n\r\n\r\n× √ × √ √\r\n\r\n\r\n\r\n\r\n\r\n× × × × √\r\n\r\n\r\n\r\n\r\n\r\n×（不含等号） 不可以（包含关系）\r\n有些问题无法在多项式时间求精确解，但可以求近似解\r\n\r\n\r\n\r\n\r\ncheck-4\r\n\r\n\r\n\r\ncheck-5\r\n\r\n\r\n\r\ncheck-6\r\n\r\n\r\n\r\n模拟算法：\r\n模拟就是用计算机来模拟题目中要求的操作。模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。\r\n近似算法：\r\n在计算复杂性理论中的某些假设下，比如最著名的 假设下，对于一些可已被证明为NP完全的优化问题，无法在多项式时间内精确求到最优解，然而在现实或理论研究中，这类问题都有广泛的应用，在精确解无法得到的情况下，转而依靠高效的近似算法求可以接受的近似解。近似算法的研究也是当今计算机科学研究的一个主要方向。（有近似精度的要求）\r\n随机算法：\r\n在算法的过程中引入随机数，使得算法在执行的过程中随机选择下一个计算步骤。它最后可能导致结果也是不确定的。一个结果不确定的概率算法叫做\r\nMonte Carlo 算法，而总是得到准确解的概率算法叫做 Sherwood\r\n算法（一个例子是引进随机因子的快速排序算法）。\r\nMaster theorem\r\n \r\nAmortized analysis\r\n聚合分析（Aggregate\r\nAnalysis）通过计算一系列操作的总成本，并将其平均到每次操作上，从而得出每次操作的均摊时间复杂度。\r\n以动态数组为例，首先，可以得到插入操作的两个关键成本：\r\n\r\n如果数组未满，插入操作的成本为 。\r\n如果数组已满，则插入操作需要扩容，扩容后复制元素的成本为 ，其中  为当前数组的大小。\r\n\r\n所以，为了计算 n 次插入操作的总成本，可以将其分开为两部分计算：\r\n\r\n插入操作的成本：每次插入新元素的直接成本是常数时间\r\n，对于  次操作，总成本是 。\r\n数组扩容的成本：每次扩容涉及到复制原数组元素到新数组。这些操作发生在数组大小为\r\n 的时刻，其中\r\n 是小于等于  的最大幂。扩容操作的成本分别是 ，总和为 ，这是一个等比数列的和，其结果为 。\r\n\r\n因此，该数组总的插入成本为 ，均摊到每次操作的成本为 。即使在最坏情况下，平均每次插入操作的成本依然是常数时间。\r\nNP problems\r\nP类问题：\r\n在确定型图灵机上能使用多项式时间的算法得到该问题的\r\n解（显然能在多项式时间内对问题进行验证）\r\nNP类问题： 在非确定型图灵机上能使用多项式时间进行\r\n验证 的问题（在现有算法下不一定能以多项式时间解决） -\r\nP类问题是NP类问题的子集 - 例子：旅行商问题TSP\r\n即有一个推销员，要到n个城市推销商品，他要找出一个包含所有n个城市的环路，这个环路路径小于a\r\n问题约化： 可以用问题B的算法来解决A\r\n，我们就说问题A可以约化成问题B。（二元一次方程的解法可以用于解一元一次方程）约化具有传递性。存在最大的问题。\r\nNPC类问题：\r\n存在这样一个NP问题，所有的NP问题都可以约化（多项式规约）成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：\r\n首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。\r\nNP-Hard问题：\r\nNP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比\r\nNPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是它不一定是一个NP问题。\r\n\r\n\r\nnp\r\n\r\nDivide and Conque\r\n\r\nProb-1\r\n设X[0:n-1]和Y[0:n-1]为两个数组，每个数组中含有n个已排好序的数。试设计一个O(logn)时间的分治算法，找出X和Y的2n个数的中位数，并证明算法的时间复杂性为O(logn)\r\n问题同上，只是X[0:m-1]和Y[0:n-1]，两有序数组长度不同，试设计一个O(log(m+n))时间的分治算法\r\n\r\n\r\n两个数组长度相等时：\r\n\r\n\r\n算法：考虑  数组中间位置的值\r\n，若 ，则说明  位于整个\r\n 个值的后半部，因此中位数在  和  之中；若 ，则说明  位于所有\r\n 个数的前半部，因此中位数在  和\r\n 之中；否则 \r\n就是中位数。若上一步没有找到中位数，则从  数组开始查找中间值，将中间值与 \r\n数组对应位置的值比较。递归上述步骤直到找到中位数。\r\n复杂度：最好情况是一次寻找就能找到中位数 ，最坏情况是每次只能去掉  的规模的数据，复杂度公式为 ，根据 Master\r\nTheorem，\r\n\r\n\r\n两个数组长度不等时：\r\n\r\n\r\nProb-2 \r\n\r\ndef merge(self, left, right):    # 记录目前左右建筑物的高度    lheight = rheight = 0    # 位置    l = r = 0    # 输出结果    res = []    while l &lt; len(left) and r &lt; len(right):        if left[l][0] &lt; right[r][0]:            # current point            cp = [left[l][0], max(left[l][1], rheight)]            lheight = left[l][1]            l += 1        elif left[l][0] &gt; right[r][0]:            cp = [right[r][0], max(right[r][1], lheight)]            rheight = right[r][1]            r += 1        # 相等情况        else:            cp = [left[l][0], max(left[l][1], right[r][1])]            lheight = left[l][1]            rheight = right[r][1]            l += 1            r += 1        # 和前面高度比较，不一样才加入        if len(res) == 0 or res[-1][1] != cp[1]:            res.append(cp)    # 剩余部分添加进去    res.extend(left[l:] or right[r:])    return res\r\n\r\nProb-3\r\n最大子数组问题。一个包含n个整数（有正有负）的数组A，设计一O(nlogn)算法找出和最大的非空连续子数组。对于此问题你还能设计出O(n)的算法吗？\r\n- 例如：[0, -2, 3, 5, -1, 2]应返回9，[-9, -2, -3, -5, -3]应返回-2\r\n\r\n见DP\r\n\r\nProb-4\r\n循环移位问题。给定一个数组，数组中元素按从小到大排好序，现将数组中元素循环右移若干位，请设计一算法，计算出循环右移了多少位。\r\n\r\n分治，合并时检查是否存在&gt;的数，若存在直接返回，位数即栈中的偏移量加上合并发现&gt;的位置\r\n\r\nProb-5 两元素和为 X。给定一个由 n 个实数构成的集合 S\r\n和另一个实数x，判断 S 中是否有两个元素的和为\r\nx。试设计一个分治算法求解上述问题，并分析算法的时间复杂度。\r\n\r\n遍历加二分查找：先排序，复杂度  遍历每一个实数复杂度为 ，在剩余未遍历的集合中查找 ，复杂度 。总复杂度 。\r\n\r\nProb-6\r\n有一实数序列𝑎_1,𝑎_2,…,𝑎_𝑁，若𝑖&lt;𝑗 且 𝑎_𝑖&gt;𝑎_𝑗，则(𝑎_𝑖,𝑎_𝑗)构成了一个逆序对，请使用分治方法求整个序列中逆序对个数，并分析算法的时间复杂性。\r\n- 例如：序列(4,3,2)逆序对有(4,3)，(4,2)，(3,2)共3个\r\n\r\n归并排序统计逆序对。在合并时注意：若左半部分大于右半某个值，则左半部分后续的值都大于它。\r\n\r\n\r\nmerge\r\n\r\n\r\nProb-7 给定 \r\n个区间，求它们的最大交区间。\r\n\r\nDynamic Programming\r\n\r\n可以在多项式时间内解决问题\r\n\r\n\r\nProb-1 给出N个1-9的数字\r\n(v1,v2,…,vN)，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。说明其具有优化子结构性质及子问题重叠性质。\r\n- 例如： N=5, K=2，5个数字分别为1、2、3、4、5，可以加成： - 1 * 2 * (3 +\r\n4 + 5) = 24 - 1 * (2 + 3) * (4 + 5) = 45 - (1 * 2 + 3) * (4 + 5) =\r\n45\r\n\r\n优化子结构性质\r\n优化子结构性质意味着问题的最优解包含其子问题的最优解。对于这个问题，我们可以将整个序列分为两部分，分别求解这两部分的最大值，然后将这两部分的最大值通过加号或乘号连接起来，以获得整个序列的最大值。\r\n子问题重叠性质\r\n子问题重叠性质意味着在递归求解过程中，相同的子问题会被多次计算。在这个问题中，当我们计算不同分割点的最大值时，很多子序列会被重复计算，因此我们可以将这些子序列的结果存储起来，避免重复计算。\r\n动态规划解决方案 我们可以定义一个二维数组 dp[i][j] 表示从第 i\r\n个数字到第 j 个数字之间插入乘号和加号能得到的最大值。我们的目标是计算\r\ndp[0][N-1]。\r\n状态转移方程 对于任意的 i 和 j（i &lt; j），我们有两种选择：\r\n在 i 和 j 之间插入一个加号，那么问题就变成了求解 dp[i][k] 和\r\ndp[k+1][j] 的最大值，其中 k 是 i 和 j\r\n之间的某个分割点，然后我们将这两个结果相加：dp[i][j] = max(dp[i][j],\r\ndp[i][k] + dp[k+1][j])。 在 i 和 j\r\n之间插入一个乘号，那么问题就变成了求解 dp[i][k] 和 dp[k+1][j]\r\n的乘积，其中 k 是 i 和 j 之间的某个分割点：dp[i][j] = max(dp[i][j],\r\ndp[i][k] * dp[k+1][j])。 我们需要枚举所有可能的 k 来更新 dp[i][j]。\r\n初始化 dp[i][i] = v[i]，因为只有一个数字，不需要任何操作。 计算顺序\r\n我们按照 j - i 的长度从小到大计算 dp[i][j]，这样可以确保在计算 dp[i][j]\r\n时，其子问题 dp[i][k] 和 dp[k+1][j] 已经被计算过。\r\n返回值 最终，dp[0][N-1] 将给出整个序列的最大值。\r\n\r\nProb-2 给定一长度为N的整数序列(a1,a2,…,aN)\r\n，将其划分成多个子序列（此问题中子序列是连续的一段整数），满足每个子序列中整数的和不大于一个数\r\nB，设计一种划分方法，最小化所有子序列中最大值的和。说明其具有优化子结构及子问题重叠性质\r\n例如：\r\n序列长度为8的整数序列(2,2,2,8,1,8,2,1)，B=17，可将其划分成三个子序列(2,2,2)，(8,1,8)以及(2,1)，则可满足每个子序列中整数和不大于17，所有子序列中最大值的和12为最终结果。\r\n\r\n考虑子问题： ， 显然当存在 \r\n有更小值时，将该值替换问题的最优解，可以得到更优解，因此原问题最优解不成立而矛盾，所以该问题具有最优子结构。而在计算\r\n 时由于要遍历 \r\n而产生重复值计算的值，因此具有子问题重叠性质。\r\n\r\nProb-3\r\n对一棵树进行着色，每个结点可着黑色或白色，相邻结点不能着相同黑色，但可着相同白色。令树的根为r，请设计一种算法对树中尽量多的节点着黑色。\r\n\r\n只有两种情况：（1）根节点为黑色 0，子节点只能为白色\r\n1，（2）根节点为白色，子节点可黑可白，  维护DP表。递推公式是\r\n\r\n\r\n当节点是叶子节点时，\r\n\r\nProb-4\r\n在自然语言处理中一个重要的问题是分词，例如句子“他说的确实在理”中“的确”“确实”“实在”“在理”都是常见的词汇，但是计算机必须为给定的句子准确判断出正确分词方法。一个简化的分词问题如下：给定一个长字符串y=y1y2…yn，分词是把y切分成若干连续部分，每部分都单独成为词汇。我们用函数quality(x)判断切分后的某词汇x=x1x2…xk的质量，函数值越高表示该词汇的正确性越高。分词的好坏用所有词汇的质量的和来表示。例如对句子“确实在理”分词，quality(确实)\r\n+ quality(在理) &gt;\r\nquality(确)+quality(实在)+quality(理)。请设计一个动态规划算法对字符串y分词，要求最大化所有词汇的质量和。（假定你可以调用quality(x)函数在一步内得到任何长度的词汇的质量）\r\n\r\n递推公式：\r\n\r\nProb-5 给定 𝑛\r\n个活动，活动𝑎_𝑖表示为一个三元组(𝑠_𝑖,𝑓_𝑖,𝑣_𝑖)，其中𝑠_𝑖表示活动开始时间，𝑓_𝑖表示活动的结束时间，𝑣_𝑖表示活动的权重。带权活动选择问题是选择一些活动，使得任意被选择的两个活动𝑎_𝑖和𝑎_𝑗执行时间互不相交，即区间[𝑠_𝑖,𝑓_𝑖]与[𝑠_𝑗,𝑓_𝑗]互不重叠，并且被选择的活动的权重和最大。请设计一种方法求解带权活动选择问题。\r\n\r\n\r\n先将活动按照结束时间排序，定义最早结束的活动到第  个结束的活动的最优排列方案是 ，结束时间早于  的活动集合的最优排列方案为 ，则 \r\n 满足最优子结构：\r\n重叠子问题集合：\r\n空间复杂度 ，时间复杂度\r\n\r\n\r\n\r\nProb-6 受限最短路径长度问题：给定一无向图G=(V, E, A,\r\nB)，A(e)表示边e的长度，B(v)表示顶点v的花费，计算小明从顶点s到顶点d的最短路径长度，满足以下限制，初始时小明随身携带M元钱，每经过一个顶点v，须交B(v)的过路费，若身上有大于B(v)的钱则可以通过，否则不可以通过。求顶点s到顶点d的最短路径\r\n\r\n递推公式：\r\n然后BFS从开始节点遍历子节点，注意记忆化存储\r\n\r\nProb-7\r\n给定𝑛个物品，每个物品有大小𝑠_𝑖，价值𝑣_𝑖。背包容量为𝐶。要求找到一组物品，这些物品整包完全占满背包容量𝐶，且总体价值最大。请写出动态规划迭代公式。\r\n\r\n设  表示装入前  个物品时，容量为  的背包的最大总价值。\r\n递推公式： 或者 \r\n每个物品只能放一次，因此是0-1背包，注意内层循环需要反向，最后需要检查背包是否占满（==）\r\n\r\nProb-8\r\n最大子数组问题：一个包含n个整数（有正有负）的数组A，设计一O(nlogn)算法找出和最大的非空连续子数组。（例如：[0,\r\n-2, 3, 5, -1, 2]应返回9，[-9, -2, -3, -5, -3]应返回-2。）\r\n\r\n DP解法： 递推公式：，找到DP数组，再找DP数组的最大值\r\n\r\nDC解法：合并跨越中线的数组时遍历即可，注意左边是  右边是 。\r\n\r\nProb-9\r\n最长非降子序列：一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。\r\n\r\n对于长度为 \r\n的子序列的最后一个元素的最小值 ，如果新来的元素大于它，就插入到  数组末尾（说明长度为 \r\n时，子序列最后一个元素最小是这个新来的元素）；如果小于它，则用二分查找，找第一个大于新元素的，用新元素\r\n替换 它 （假设找到的位置是  即在不降子序列长度为  时，末尾的元素还能更小）。\r\n对于最长 上升 子序列问题，类似地，可以令 d_i 表示所有长度为 i\r\n的最长上升子序列的末尾元素的最小值。\r\n需要注意的是，若 ，由于最长上升子序列中相邻元素不能相等，需要在 d\r\n序列中找到 第一个 不小于 \r\n的元素，用  替换之。\r\nGreedy\r\n\r\nProb-1\r\n给定n个物品，物品价值分别为P1，P2，…，Pn，物品重量分别W1，W2, …,\r\nWn，背包容量为M。每种物品可部分装入到背包中。输出X1，X2，…，Xn，0&lt;=Xi&lt;=1,\r\n使得 \r\n最大，且 。试设计一个算法求解该问题，分析算法的正确性。\r\n\r\n\r\nProb-2\r\n海面上有一些船需要与陆地进行通信，需要在海岸线上布置一些基站。现将问题抽象为，在x轴上方，给出N条船的坐标𝑝_1,𝑝_2,…,𝑝_𝑁，𝑝_𝑖=(𝑥_𝑖,𝑦_𝑖)，𝑥_𝑖≥0,\r\n𝑦_𝑖≤d,1≤𝑖≤𝑁，在x轴上安放的基站可以覆盖半径为d的区域内的所有点，问在x轴上至少要安放几个点才可以将x轴上方的点都覆盖起来。试设计一个算法求解该问题，并分析算法的正确性。\r\n\r\n\r\n\r\nProb-3\r\n某公司有个工厂和仓库。由于原材料等价格波动，工厂每个月的生产成本也会波动，令第𝑖个月产品的单位生产成本为𝑐_𝑖（该月生产一个产品的成本为𝑐_𝑖）。仓库储存产品的也有成本，假设每个月产品的单位储存成本为固定值1（存储一个产品一个月的成本为1）。令第𝑖个月需要供应给客户的产品数量为𝑦_𝑖，仓库里的和生产的产品均可供应给客户。假设仓库的容量无限大，供应给客户剩余的产品可储存在仓库中。若已知𝑛个月中各月的单位生产成本𝑐_𝑖、以及产品供应量𝑦_𝑖，设计一算法决策每个月的产品生产数量𝑥_𝑖，使得𝑛个月的总成本最低。例如：𝑛=3，𝑐_𝑖:2,5,3，𝑦_𝑖:2,4,5，则𝑥_𝑖:6,0,5，即第1个月生产6个供应2个（代价2×2=4），储存4个供应给第2个月（代价(2+1)×4=12），第3个月生产5个供应5个（代价3×5=15），使总成本4+12+15=31最小\r\n\r\n\r\nProb-4 给定直线上 2n个点的序列P[1,2,… ,2n]，每个点\r\nP[i]要么是白点要么是黑点，其中共有n个白点和\r\nn个黑点，相邻两个点之间距离均为1，请设计一个算法将每个白点与一黑点相连，使得连线的总长度最小。例如，图中有4个白点和4个黑点，以图中方式相连，连线总长度为1+1+1+5=8。\r\n\r\n\r\n\r\nProb-5\r\n有n个作业需要在一台机器上执行，一个时刻机器上只能执行一个作业，每个作业可在单位时间内完成，作业i有截止时间di，当作业i在截止时间被执行完，则可获得pi的收益，请设计算法获得最大收益，并分析算法的正确性\r\n\r\n\r\nProb-6\r\n假设有数目不限的面值为25美分，10美分，5美分，1美分的硬币，请使用最少个数的硬币凑出3.33美元。\r\n\r\nSearching\r\n\r\nProb-1  \r\n请从给定的点数网格𝒂[𝟏,𝟐,…,𝟕][𝟏,𝟐,…,𝟖]使用搜索算法求出对应\r\n的骨牌号图𝒃[𝟏,𝟐,…,𝟕][𝟏,𝟐,…,𝟖]，有可能的话，给出相关剪枝策略。\r\n\r\nNetwork flow/Bipartition\r\nmatching\r\nFord-Fulkerson alg\r\n适用于稠密图，可以用DFS找增广路，时间复杂度为 ， 是最大流量：\r\n\r\n搜索出一条增广路；\r\n在这条路径中所有的边容量减去这条增广路的流量，并建立流量为增广路增加流量相反数的反向边；\r\n返回操作一，如果没有增广路则得到答案\r\n\r\n/**  * 查找增广路  * @param c 当前节点  * @param t 汇点  * @param f 当前路径中的容量最小值  * @return  */int dfs(int c, int t, int f) {    // 如果当前节点是汇点 t，直接返回容量最小值，即增广路增加的流量    if (c == t) {        return f;    }    // 记忆化搜索染色    used[c] = true;    // 遍历 c 节点下一个节点    for (int i = 0; i &lt; G[c].size(); ++ i) {        Edge &amp;e = G[c][i];        // 如果这个节点未被访问到，并且其当前容量大于 0        if (!used[e.to] &amp;&amp; e.cap &gt; 0) {            // 访问到最深层节点            int d = dfs(e.to, t, min(f, e.cap));            if (d &gt; 0) {                // 当前边容器减少                e.cap -= d;                // 反向边容量增加                G[e.to][e.rev].cap += d;                return d;            }        }    }    return 0;}int max_flow(int s, int t) {    int flow = 0;    int cnt = 0;    for (;;) {        memset(used, 0, sizeof(used));        int f = dfs(s, t, INF);        cnt += 1;        if (f == 0) {            cout &lt;&lt; cnt &lt;&lt; endl;            return flow;        }        flow += f;    }}\r\nEdmond-Karp alg\r\n适用于稀疏图，用BFS找增广路，算法复杂度为 ：\r\n\r\n使用 BFS 找到一条增广路（对应下面的步骤 1）；\r\n计算这条路的最小容量边，为汇点加流量，并建立反向边，其容量为增加的流量（对应下面的步骤\r\n2）；\r\n重复第一步，如果不能找到一条增广路则得到最大流；\r\n\r\n但是在实现上，由于我们采用了 BFS\r\n方法，则无法对这条增广路进行回溯处理。所以在代码实现的时候，我们需要通过一个数组或者一个\r\nMap 来记录下对应点在增广路上的入度边\r\n// 用来记录当前路径上的最小容量，用于加流量操作int a[MAX_V]; // 记录下标点的边编号，pair 对应 G[x1][x2]，x1 是描述哪个入度点，x2 是描述 x1 点的第 x2 条边unordered_map&lt;int, pair&lt;int, int&gt;&gt; pre; void bfs(int s, int t) {        // a 初始化成 0，也可以判断是否已经被染色，从而剪枝情况    memset(a, 0, sizeof(a));        // 使用队列，保存处理节点    queue&lt;int&gt; que;    que.push(s);        // 每个节点所流过的流量设置为 INF 无穷大        // 这样可以起到求最小的作用    a[s] = INF;    while (!que.empty()) {        int x = que.front();        que.pop();                // 遍历当前节点的所有边        for (int i = 0; i &lt; G[x].size(); ++ i) {            Edge&amp; e = G[x][i];                        // 如果相连的点没有访问，并且这条边的容量大于 0            if (!a[e.to] &amp;&amp; e.cap &gt; 0) {                                // 记录下一个点的入度边                pre[e.to] = make_pair(x, i);                                // 计算当前路径的最小容量                a[e.to] = min(a[x], e.cap);                que.push(e.to);            }        }        if (a[t]) break;    }}int max_flow(int s, int t) {        // 最大流结果    int ret = 0;    while (1) {                // 从 S -&gt; T 使用 bfs 查询一条增广路        bfs(s, t);                // 如果发现容量最小是 0 ，说明查不到了        if (a[t] == 0) break;        int u = t;        while (u != s) {                        // 使用 pre 来获取当前增广路中汇点 T 的入度边下标信息            int p = pre[u].first, edge_index = pre[u].second;                        // 获取正向边和反向边            Edge&amp; forward_edge = G[p][edge_index];            Edge&amp; reverse_edge = G[forward_edge.to][forward_edge.rev];                        // 更新流量            forward_edge.cap -= a[t];            reverse_edge.cap += a[t];                        // 逆增广路方向移动游标继续更新            u = reverse_edge.to;        }        ret += a[t];    }    return ret;}\r\n\r\nProb-1  \r\n\r\nGraph\r\nTopological sorting\r\nActivity on Vertex Network (AOV)\r\n顶点表示活动。当活动的所有前驱节点都完成，该节点才能执行。\r\n\r\n拓扑序列 构造如下\r\n\r\n从图中选择入度为0的点\r\n输出该顶点，然后从图中删除此顶点的所有出边\r\n\r\n重复上述步骤直到所有顶点都输出，拓扑排序完成；否则图中不存在入度为0的点，是有环图，死锁。\r\n\r\nActivity on Edge Network (AOE)\r\n边表示活动/权值/时间，顶点表示事件。\r\n\r\n事件（顶点）的最早发生时间 \r\n即需要所有前驱节点完成，是源点到该节点的最大路径\r\n事件（顶点）的最迟发生时间 \r\n事件的所有后继活动的最迟开始时间的最小值\r\n活动（边）的最早发生时间 \r\n活动（边）的最迟发生时间  后继事件的最迟发生时间 - 该事件的持续时间（权值）\r\n关键路径：AOE 网中从源点到汇点的最长路径的长度。\r\n关键活动：即关键路径上的活动，它的最早开始时间和最迟开始时间相等。\r\n\r\n递推求最早和最迟发生时间：\r\n按拓扑顺序求，最早发生时间从前往后递推，最迟发生时间从后往前递推\r\nKaha算法 初始状态下，集合 S 装着所有入度为 0 的点，L\r\n是一个空列表。 每次从 S 中取出一个点 u（可以随便取）放入 L, 然后将 u\r\n的所有边  删除。对于边 ，若将该边删除后点 v 的入度变为 0，则将 v 放入 S\r\n中。不断重复以上过程，直到集合 S\r\n为空。检查图中是否存在任何边，如果有，那么这个图一定有环路，否则返回\r\nL，L 中顶点的顺序就是构造拓扑序列的结果。\r\n\r\n时间复杂度：\r\n\r\nMinimum spanning tree (MST)\r\n（m是边数，n是点数）\r\nKruskal：维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。时间复杂度\r\n\r\n\r\n\r\nkruskal\r\n\r\nPrim：每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。时间复杂度\r\n（暴力查找）， （二叉堆）\r\n\r\n\r\nprim\r\n\r\nMinimum path\r\n性质\r\n\r\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。\r\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。\r\n对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过\r\nn，边数不会超过 n-1。\r\n\r\nFloyd算法：\r\n可以求任意两个结点之间的最短路。适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）\r\n\r\n设 f[k,x,y] 表示只允许经过节点 1 到 k 的 x 到 y\r\n的最短路。则最终要求的是\r\nf[n,x,y]。f[0,x,y]=0 or inf\r\nf[k,x,y] = min(f[k-1,x,y], f[k-1,x,k] + f[k-1,k,y])：分成是否经过点\r\nk 来考虑\r\n第一维对于结果无影响\r\n时间复杂度  ，空间复杂度\r\n for (k = 1; k &lt;= n; k++)  for (x = 1; x &lt;= n; x++)    for (y = 1; y &lt;= n; y++)      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);\r\n\r\nBellman-Ford算法：可以处理负权图，可以判断最短路是否存在。复杂度\r\n\r\n[bellman-ford]bellman-ford.png)\r\n\r\n需要注意的是，以 S 点为源点跑 Bellman–Ford\r\n算法时，如果没有给出存在负环的结果，只能说明从 S\r\n点出发不能抵达一个负环，而不能说明图上不存在负环。\r\n因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为\r\n0 的边，然后以超级源点为起点执行 Bellman–Ford 算法。\r\n\r\nDijkstra算法：求解非负权图单源最短路。\r\n将结点分成两个集合：已确定最短路长度的点集（记为 S\r\n集合）的和未确定最短路长度的点集（记为 T 集合）。一开始所有的点都属于 T\r\n集合。初始化 dis(s)=0，其他点的 dis 均为 。然后重复这些操作：\r\n\r\n从 T 集合中，选取一个最短路长度最小的结点，移到 S 集合中。\r\n对那些刚刚被加入 S 集合的结点的所有出边执行松弛操作。\r\n直到 T 集合为空，算法结束。\r\n\r\n时间复杂度：稀疏图 \r\n二叉堆实现更优；稠密图 \r\n暴搜优于二叉堆。\r\nstruct edge {  int v, w;};vector&lt;edge&gt; e[MAXN];int dis[MAXN], vis[MAXN];void dijkstra(int n, int s) {  memset(dis, 0x3f, (n + 1) * sizeof(int));  dis[s] = 0;  for (int i = 1; i &lt;= n; i++) {    int u = 0, mind = 0x3f3f3f3f;    for (int j = 1; j &lt;= n; j++)      if (!vis[j] &amp;&amp; dis[j] &lt; mind) u = j, mind = dis[j];    vis[u] = true;    for (auto ed : e[u]) {      int v = ed.v, w = ed.w;      if (dis[v] &gt; dis[u] + w) dis[v] = dis[u] + w;    }  }}\r\nBipartite graph\r\n性质\r\n\r\n如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。\r\n二分图不存在长度为奇数的环（可以用DFS/BFS遍历图，不存在奇数环的连通图则是二部图）\r\n\r\n最大匹配\r\n给定二分图，要求选定一些边，使得边之间没有公共顶点，且边的数量最大。\r\n\r\n交替路/增广路：从未匹配的点出发，依次交替经过非匹配边、匹配边，到达另一个非匹配点。然后对增广路上所有的非匹配和匹配取反，得到新的匹配图。（DFS，）\r\n转为最大流：源点连接左边集合，汇点连右集合，容量都为1\r\n\r\n----\r\n","categories":["Lecture"],"tags":["Lecture"]},{"title":"Paper | Represention Learning in Scene Text Images","url":"/2024/12/03/SceneTextImage/representations_learning/","content":"Vision Transformer\r\n\r\nRoFormer: Enhanced Transformer with Rotary Position\r\nEmbedding (Paper) (Code)\r\n(Ref)\r\n(Note&amp;Blog)\r\n\r\n[CVPR22] Unsupervised Hierarchical Semantic Segmentation with\r\nMultiview Cosegmentation and Clustering Transformers (Paper)\r\n(Code) (Issue)\r\n\r\n[ICLR25] An Image is Worth More Than 16x16 Patches: Exploring\r\nTransformers on Individual Pixels (Paper)\r\nMeta的一篇文章，但还在ICLR的rebuttle。主要观点是用单独的pixel作为token可以将local的归纳偏置降为零。文章类比bag\r\nof words，提出set of pixels，并在其上加上必要的positional\r\nembeddings后，输入普通的Transformer可以学习特征可以比切割patch的方式表现更好。当然计算量也更大。重要的是，作者提出可以选择性地输入像素，例如上面的一篇文章。由于没有具体的新模型，只是一个普通的研究，这里记录一些自己的笔记。\r\n\r\nViT的输入不再是以patch的方式，也就是认为patch和使用连续函数进行位置编码都会来带一定程度的归纳偏置。因此改为pixel的方式，并使用可学习的位置编码可以消除由于locality带来的归纳偏置。\r\n将输入改为pixel后，输入的方式就变得比较多样。可以是随机的像素输入，也可以是有结构性地输入，还可以是输入重要的像素等等。文章在提到这些问题的时候引用了这篇文章。\r\n可学习的位置编码很重要。\r\n无监督学习可以快速学到像素之间的想似性和像素之间的结构特征。\r\n如果有标注，依然存在对齐的问题。但是否存在一种方式可以先通过像素为本的预训练学习结构特征，再通过微调快速对其多模态特征。\r\n\r\n例如text images\r\n\r\n重要的不是学习像素（因为只有255类，相当于26字母），而是学习像素之间的相对关系，只有满足某种关系的像素集合，才能构成图像。对于text\r\nimages而言，这种关系需要满足：\r\n\r\n这种关系应该是像素集合（）到图像（）之间的映射，即一个像素需要到一个二维坐标，每个坐标需要有一个像素值，但每个像素值不一定需要坐标，即定义域是像素集合的子集\r\n能将像素映射到正确的位置从而呈现出人眼可识别的图像\r\n被映射到图像中文本区域的像素需要和embedding后的文本特征对应\r\n\r\n更强的条件：被映射到文本区域的像素需要按照顺序与embedding后的文本对齐\r\n\r\n继续思考：embedding后的文本实质上对应的是图像上的一块区域\r\n\r\n是否可以把文本进行二维编码\r\n\r\n因此需要模型能在预训练时得到图像中各个区域的隐变量表示，而在微调时快速建立其它模态与这些隐变量之间关系\r\n\r\n\r\n\r\n[ECCV22] CoMER: Modeling Coverage for Transformer-based\r\nHandwritten Mathematical Expression Recognition (Paper)\r\n(Code)\r\n本文主要针对手写数学公式识别任务魔改了ViT，把Coverage\r\nAttention引入ViT的特征层，优化Attention\r\nWeights，并进行并行解码，在降低过往注意过的区域的同时提高了解码效率。\r\n\r\n---------- Abstracts ----------\r\n\r\n\r\nBackground\r\n\r\nCoverage Attention: handle the problem in translation i.e.\r\nover-translation and under-translation, mainly used in RNN, where\r\nCoverage Attention can use the past hidden states and forces the model\r\nto attend more on unparsed parts in image. Derictly introducing Coverage\r\nAttention to ViT will break the parallel decoding of Transformer.\r\n\r\nMotivation\r\n\r\nintroduces Coverage Attention into Transformer's attention layer to\r\nrefine the attention weights in a prefix-sum form without hurting\r\nparallel decoding\r\n\r\nMethods\r\n\r\ndesigns three types of attention refinement methods i.e. self-,\r\ncross- and fusion-coverage\r\n\r\n\r\n\r\n---------- Related Work ----------\r\n\r\nCoverage Attention in RNN: for attention map  on features , the coverage vector  can be calculated by  (the prefix sum of column vectors of attention\r\nmap). Then the coverage matrix \r\nis . For RNN, there are hidden states at time step , they constract the hidden state matrix\r\n and\r\nlearnable weights , the\r\nattention vector can be get as follow:\r\n \r\n\r\n---------- Methods ----------\r\n\r\nMultipling  and  firstly and then add it to  which can\r\ndecreases the space complexity:\r\n\r\nSo the attention item \r\n\r\n\r\narm\r\n\r\nThe codes can be found in github\r\n\r\nAttention\r\n\r\nIn fact, this paper realized an alignment methods: when predicting\r\nthe label at step , the refined\r\nattention weights attend the next region in image, the region in image\r\naligns the label character at \r\n\r\n\r\n\r\nMulti-modal\r\n\r\n[CVPR24] ODM: A Text-Image Further Alignment Pre-training\r\nApproach for Scene Text Detection and Spotting (Paper)\r\n(Code)\r\n本文主要是实现了文本图像的去形式化，也就是将图片中的文本转化为标准字体，并保持一定的旋转和位置不变，输出在图片上，是一种预训练方式。但是该方式还是使用了标签作为监督。\r\n\r\n---------- Abstracts ----------\r\n\r\n\r\nMotivation\r\n\r\nin Optical Character Recognition (OCR) tasks, aligning text\r\ninstances with their corresponding text regions in images poses a\r\nchallenge, as it requires effective alignment between text (text\r\nannotation) and OCR-Text (text in image) rather than a holistic\r\nunderstanding of the overall image content\r\ntransfers diverse styles of text found in images to a uniform style\r\nbased on the text prompts\r\ncosts in scene text image annotations\r\n\r\nMethods\r\n\r\nODM model, transfer diverse form into plain form\r\nlabel generation, to allow large amount of unlabeled data to\r\nparticipate in pretraining\r\n\r\n\r\n\r\n---------- Methods ----------\r\n\r\nThis is a framework for pre-training, so the encoder and decoder can\r\nbe any model that is suitable for spotting and detection tasks. The\r\nconnection between image encoder and text encoder is a cross attention\r\nmechanism. The delicately designed part is losses.\r\n\r\nbinary segementation loss: for every pixel, calculate binary\r\ncorss-entropy loss \r\nOCR-LPIPS loss: aims to constrain the features, the output binary\r\nand ground truth images are inputed to a well trained detector (e.g.\r\nUNet-VGG with  layers), and then\r\ncalculate the sum of layer loss \r\ncontrastive loss: maps texts and images into the same semantic\r\nspace, calculate loss \r\ntotal loss: \r\n\r\n\r\n[CVPR24] Multi-modal In-Context Learning Makes an\r\nEgo-evolving Scene Text Recognizer (Paper)\r\n(Code)\r\n\r\n---------- Abstracts ----------\r\n\r\n\r\nMotivations\r\n\r\ndifficult to transfer to different domain for STR (such as font\r\nsdiversity, shape deformations)\r\nfine-tuning is computationally intensive and requires multiple model\r\ncopies for various scenarios\r\nLLMs with in-context learning fail as the insufficient incorporation\r\nof contextual information form diverse samples in the training stage\r\n(?)\r\nIn summary: STR models needs fine-tuning to satisfy new scenorios\r\nwhich costs too much. So this paper wants to borrow the ICL in LLM to\r\ndecrease the costs\r\n\r\nMethods\r\n\r\ntrain with context-rich scene text sequences (sequences are\r\ngenerated by in-context training strategy)\r\nregular size model is enough\r\n\r\nQuestions\r\n\r\nwhat is \"context-rich\", how to depict \"rich\"\r\n\r\n\r\n\r\n---------- Related Work ----------\r\n\r\n\r\nMulti-modal in In-context learning, training-free\r\n\r\nLLMs can quickly adapt to new tasks with just a few examples (treat\r\nthese inputs as prompt), this phenomenon is a new learning paradigm\r\ntermed \"In-Context Learning\", which means \"The label is the input\r\nitself\". But it's difficult to transfer the learning paradigm to\r\nVLMs\r\n\r\n\r\n\r\n---------- Methods ----------\r\n\r\nModel Architecture\r\n\r\n\r\nE2STR Model\r\n\r\n\r\nModel trained in the standard auto-regressive paradigm to learn\r\nfundamental STR ability\r\nIn-Context training, learn to understand the connection among\r\ndifferent samples\r\ninference, fetches in-context prompts based on visual\r\nsimilarity\r\n\r\nTraining Strategy\r\n\r\nTrain with original training set\r\nGenerate splited and transformed samples and then concatenate them\r\nin a sequence form. Train with these sequences.\r\n\r\nInference\r\nInference needs to maintain an In-Context Pool, where the k-NN\r\nseletion strategy will be conducted. k-NN will select top-K similar\r\nsamples in latent space to form the prompts\r\n\r\n\r\nE2STR split strategy\r\n\r\n\r\nAttention\r\n\r\nThe split phase faces the difficulty of alignment, especially for\r\nart texts, which can't be splited by a single rectangle (so\r\nwhat about a deformable shape?)\r\nInference should maintain an In-Context pool\r\n\r\n\r\n\r\nDistangle Representions\r\n\r\n[CVPR24] Choose What You Need: Disentangled Representation\r\nLearning for Scene Text Recognition Removal and Editing (Paper)\r\n这篇文章主要是使用了额外的数据集用于提取解耦特征，从数据角度解决特征耦合的问题。\r\n\r\n---------- Abstracts ----------\r\n\r\n\r\n\r\narch_1\r\n\r\n\r\nMotivations\r\n\r\nprevious representation learning methods use tightly coupled\r\nfeatures for all tasks, resulting in sub-optimal performance\r\ndisentangling these two types (style feature and context feature) of\r\nfeatures for improved adaptability in better addressing various\r\ndownstream tasks\r\n\r\nMethods\r\n\r\nDataset: we synthesize a dataset of image pairs with\r\nidentical style but different content, the dataset generator is SynthTIGER\r\nLosses: content features are supervised by a text recognition\r\nloss, while an alignment loss aligns the style features in the image\r\npairs\r\n\r\n\r\n\r\n---------- Related Work ----------\r\n\r\nTo illustrate the drawbacks of using tightly coupled features.\r\n\r\nSTR with segementation preprocessing\r\n\r\nSIGA\r\nCCD\r\nDeformable CNN\r\nuse a learnable bias in convolution block to represent deformations\r\n\r\n\r\n\r\n---------- Methods ----------\r\n\r\nThe total model is divided into two part, one for generation and the\r\nother for recognition. Both parts use MSA to extract features but with\r\ndifferent losses. The gradients in context part are blocked to realize\r\ndecouple target. For multiply layer, model uses gated strategy to fuse\r\nmulti-layer features.\r\n\r\nAttention\r\n\r\nThis model divides style and context fetures with the SAME lengths,\r\nwhich may constrain the ability to represent background information,\r\nbecause the background is assumed more complex than texts.\r\n\r\n\r\n\r\n","categories":["Multi-Modal"],"tags":["Multi-Modal"]},{"title":"致谢 | 我经历过的微风、夕阳和大海","url":"/2024/05/30/You/acknowledgement/","content":"2020级SEU本科毕业致谢篇。谨以此文，献给自己。\r\n很多年过去，我还是喜欢那一座城市\r\n在内心毫无波澜甚至有些许失望的情况下接受了高考的第三志愿的第二专业：SEU吴健雄学院。填写志愿时并无对任何专业有过多的了解，凭本事选择了大类培养的吴健雄学院。同样，对于未来的大学生活我也没有任何期待和了解。我从午休的床上起来，正值盛夏，在湖中心。民宿的周围有野花盛开，清澈湛蓝的水波轻拍岸沿。阳光也是懒散的。\r\n几周前我结束了长沙之行。长沙城是一座内陆城市，通过湘江与长江相接，在高中时便经常背诵“君住长江头，妾住长江尾。夜夜思君不见君，共饮长江水”，如今站在橘子洲头，确实能感受到四面奔腾的湘江水带来的无尽的哀愁。去逛了博物馆和美术馆，我还是觉得美术馆更适合我，不同的心情可以有不同的思考，没有答案的作品可以让我进行二次创作，我是自由而孤独的。美术馆的灯光打在红色的墙上，我拍下了黑色的影子。但随后我删了，因为我以为以后还能再见。茶颜悦色在这座城市开得到处都是，第一次被称呼“许小主”的心情还带着些许奇妙，喝了很多饮品，我还是喜欢幽兰拿铁，以至于上大学后在网易云中去搜幽兰拿铁，竟然还能搜到相关的歌曲。不过后来，南京也有了茶颜，但我已经没有了那种好奇和兴奋的感觉。当然，在彻底爱上这座城市前，也无法忘记那一天的炎热，与当时自己乘公交前往一个偏远的地方时的稚嫩与愚笨。博物馆和艺术馆的照片仍然存在手机相册里，茶颜悦色和文和友消失在夜晚的草地。热闹的街景，谁与谁又并肩牵手穿梭于夏天的夜晚与记忆的牢笼。\r\n牢笼仍在，我却很久没有回到长沙城。\r\n\r\n\r\n长沙\r\n\r\n但是接到志愿通知的时候我却无法开心。我会回想起高中夏日粉色和紫色的夕阳与金色的树黑色的鸟，一声吱呀，定格了无法回去的夏天。18年的分号停留在了通知书寄到手边的那一刻。\r\n随之而来的是死寂般的沉默与一个月的暑假和三次前往同一片湖度假。\r\n就是我现在看着的这片湖。我试着在深夜拍摄星轨，我喜欢积雨云中倾泻的阳光。\r\n一个月后的南京，至今竟然已经蜗居四年之久。\r\n星期三，南京大雨\r\n带着大一新生独有的清澈心灵与眼眸，与父母在东南大学北门告别后，我踏入陌生的校园。只不过再次转身时，已经看不见他们了。\r\n仍然无法确定中学是否结束，18岁是否已过。在整理床铺的时候突然会想起在家旁边的公园里，LED灯中有人弹着吉他，我竟然有点想哭。我才明确地知道，这里是南京，是名为东南大学的校园，是桃园宿舍。在公众号中出现过的健雄书院如今就在我眼前。即使很累，我还是带着我的通知书去了各种东大的打卡地。——图书馆和大草坪，教学楼，九龙湖。坐在图书馆的台阶上，无人分享和倾诉。有时有人从图书馆出来，有时有人前往图书馆。我感到劳累和疲惫，在陌生的阳光下。\r\n于是车载着我没头没脑地开始往前开，蛮横地冲撞时间，我却把记忆忘在了起点，忘在了长沙南站的分别。都说被记住的才是生活，在下车时，我开始寻找自己的生活。但我撞不开时间。我回不去起点。\r\n要我说，大一堆砌的是中值定理与各种积分。在周围人的口算题中绞尽脑汁，在月光下一个人回寝。我很早就知道了6号和8号教学楼三四楼不锁门不关灯，于是我经常在里面宅一天。我不爱回寝室，即使在偌大的阶梯教室里望着窗外，如笼中之鸟。开始熬夜，开始享受这种没有人打扰的思考与独处，开始沉默，开始戴着耳机听歌。最常见的景色就是夕阳照到交通楼，呈现金黄，或是天空出现粉橙的脸颊，以及写满的草稿纸，和没有结果的题目。我明白我陷入了一个神秘而可怕的深渊之中，但我不能自救。我强迫自己去散步，不允许沉沦。\r\n当时最开心的还有梅园操场上一排金色的银杏，一周后被砍了。剩下灰色的枯叶和惨白的天空。以及即将到来的冬天。\r\n\r\n\r\n银杏\r\n\r\n我开始记录一些自己的想法。在一些人看来，写日记就是在欺骗自己。但是我喜欢那一本小王子封面的日记本，小王子、B612和一朵玫瑰以及44次日落。有一个人对我说：\r\n\r\n压力都是自己给的，不用和别人比，朝着自己的方向走吧。时间管理是你最擅长的。大学每个人的放心都不一样，没有必要因为别人怎么样自己就怎么样。放弃一些让自己不舒服的社交圈，实在憋得喘不过气就不用我告诉你怎么做吧。\r\n每个人都在黑暗中探索，你前面有很多人，没有办法，你只能跟着拿蜡烛的他们。\r\n但是你有没有想过，你可以自己拿着蜡烛去自己想去的地方。\r\n\r\n我不管那个人懂不懂我的劳累，我的压力和孤独。但那个人听完了。\r\n我没有办法去草地上听乐队演奏，即使夕阳很美。悔恨吗，或许吧，一把跨越七年的刀刃插进了不成熟的内心。我没有想过我可以自己拿着蜡烛去自己想去的地方。或许想过。或许一定想过。如今却站在了四年的末尾，回望四年或七年的所有是非，有时候能看见一点光亮。\r\n一个人和一群人\r\n我总觉得应该去找寻或者思考一些什么，历史也好，哲学也罢。只有思考时，我才能感受到自己存在于世界，双脚真正站在陆地上，双眼看着飞鸟。一昧的自责和反思只会加剧自卑感和乏力感，但当你开始把视线投向更远的远方时，才能感受到当下的存在和历史的实体。当时自己的内心一定是烦躁不安的，我希望去改变一些什么，任何方向都行。因为最差的结果是维持现状。让我印象颇为深刻的是疫情延迟放假，我在第一次在图书馆度过夏天。喜欢那里傍晚的鸟鸣，有薄荷的味道和天空的清澈。更重要的是让我莫名其妙增加了在计算机上的兴趣和自信。这种自以为是让我选择了AI和CS作为专业。\r\n后来我一个人去了北京。竟然真的能在早晨的四合院中看见逗鸟的大爷。一个人爬完长城南北两段后无法忘记在烽火台上清爽的风。租一辆车骑完整条长安街。喝一碗豆汁儿。在蓝调的白塔公园感受寒冷和肃杀。南锣鼓巷不长但终于看见一点烟火气。\r\n\r\n雨，雾\r\n乌鸦的叫声\r\n马路上飞驰的车辆\r\n护城河，一浪接一浪\r\n秋也是凉的\r\n世事一场大梦\r\n红色的宫墙又在上漆\r\n凹凸不平的石砖有点硌脚\r\n五千年一晃而过\r\n游客还在拍照\r\n\r\n已经忘了很多事情。也忘了暑假结束后是为何来到书院并加入其中成为志愿者的。“海看多了想见人，人见多了想看海”。于是命运的齿轮开始转动。\r\n我很少对已经发生的事情做一些相反的设想，因为这些设想的目的往往是加强对当下的信念感，但我还是无法想象如果我当初没有来到书院，我现在在哪，后续的两年又会如何度过，或者会更优秀，或者会更差劲。唯一清楚的是，人是群居动物，至少我无法长时间忍受失去交流的生活。很多事情很多矛盾很多情绪，见一面就好了。除非累了。一个人的价值是通过“被需要”体现的，这种“被需要”在我第一次来书院时展现得淋漓尽致，因为我否定自己太多了。虽然还是不怎么回寝室，但终于不是一个人在教室最后一排看着夕阳发呆了。对于所谓大学的记忆也开始变得有迹可循。书院、校队和活动室都成为了我的大学。\r\n现在的故事\r\n后来的我\r\n","categories":["You"],"tags":["You"]}]